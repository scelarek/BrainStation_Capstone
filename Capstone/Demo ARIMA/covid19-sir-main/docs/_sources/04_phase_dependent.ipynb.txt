{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "i-djSSWUOSGs"
      },
      "source": [
        "[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/lisphilar/covid19-sir/HEAD?labpath=example%2F04_phase_dependent.ipynb)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Phase-dependent SIR models\n",
        "SIR-derived ODE models (SIR, SIR-D, SIR-F) assume that ODE parameter values are always constant. Can we apply this assumption to real data?\n",
        "\n",
        "[Kaggle: COVID-19 data with SIR model](https://www.kaggle.com/code/lisphilar/covid-19-data-with-sir-model/notebook) concluded this was No - ODE parameter values change with phases - because measures taken by people changed the situation of COVID-19 outbreak actually. Term \"phase\" means a sequential dates in which the parameters of SIR-derived models are constant. To remove fluctuations from analysis, \"time-dependent\" should be avoided.\n",
        "\n",
        "---\n",
        "\n",
        "The first section will show the dynamics of phase-dependent SIR models with sample data. \n",
        "\n",
        "The Kaggle notebook also suggested detailed steps of applying phase-dependent SIR models to actual data. The second section demonstrates how to divide actual time-series data to phases (time-series segmentation with \"S-R change point analysis\"). The third section is to estimate ODE parameter values of phases (\"ODE parameter estimation\").\n",
        "\n",
        "With fourth section, we will perform them with actual data of Tokyo/Japan as an example."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 507
        },
        "id": "xFEXKhrGTlzK",
        "outputId": "66cb9f76-7ffe-4391-c54b-ffb1ef6c17c6"
      },
      "outputs": [],
      "source": [
        "from copy import deepcopy\n",
        "from pprint import pprint\n",
        "import covsirphy as cs\n",
        "import sympy\n",
        "cs.__version__"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "kR6yKAicSltb"
      },
      "source": [
        "## 1. Dynamics of phase-dependent SIR models\n",
        "Using `Dynamics` class, we will simulate phase-dependent SIR model with sample data (two phase) as an example.\n",
        "\n",
        "The 0th phase: 01Jan2022 - 28Feb2022, rho=0.2, sigma=0.075 (preset)  \n",
        "The 1st phase: 01Mar2022 - 30Jun2022, **rho=0.4**, sigma=0.075\n",
        "\n",
        "tau value: 1440 [min] (default)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "WB58I3HrTZ3O"
      },
      "source": [
        "### 1-1. Define the 0th phase\n",
        "As the first step, define the 0th (initial) phase with preset ODE parameter values."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 112
        },
        "id": "G619MsL1ORsV",
        "outputId": "a1bbe065-9112-48b2-e36e-6dab4fdf8d84"
      },
      "outputs": [],
      "source": [
        "dyn = cs.Dynamics.from_sample(cs.SIRModel, date_range=(\"01Jan2022\", \"30Jun2022\"), tau=1440)\n",
        "# Show summary\n",
        "dyn.summary()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "-NSzHSEmVAnh"
      },
      "source": [
        "### 1-2. Define the 1st phase\n",
        "Get the current settings of initial values of variables and ODE parameter values as a `pandas.DataFrame`. Then, edit it and register it to the instance."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 455
        },
        "id": "2hYtsbSaVX3z",
        "outputId": "bb5b88e3-06d7-44b6-b049-7299eb903bd6"
      },
      "outputs": [],
      "source": [
        "before_df = dyn.register()\n",
        "before_df"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "2y5M1xMIVi4d"
      },
      "source": [
        "Without NAs:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 112
        },
        "id": "JqggdENIVlO5",
        "outputId": "cb49af21-9823-4ea1-b1f9-38ce16e42809"
      },
      "outputs": [],
      "source": [
        "before_df.dropna(how=\"all\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "_zdacZ-pVi-F"
      },
      "source": [
        "Edit the dataframe to set the ODE parameter values of the 1st phase."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 455
        },
        "id": "xAtyvN_SWJcx",
        "outputId": "6770595f-8a88-4808-8d8c-689db65bb696"
      },
      "outputs": [],
      "source": [
        "setting_df = dyn.register()\n",
        "setting_df.loc[\"01Mar2022\", [\"rho\", \"sigma\"]] = [0.4, 0.075]\n",
        "setting_df"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "qHPmQ4D7WFfh"
      },
      "source": [
        "Without NAs:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 143
        },
        "id": "-HiBH5R5WN2J",
        "outputId": "15c9d086-1d56-4710-fd46-c8040fe02da1"
      },
      "outputs": [],
      "source": [
        "setting_df.dropna(how=\"all\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "_p6KSrETW3C3"
      },
      "source": [
        "Register the new settings. Because initial values on 01Mar2022 will be calculated with analytical solution of the 0th phase, they were not registered manually."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 143
        },
        "id": "Ky5WpuGkW2Pb",
        "outputId": "59c6c3a6-10f8-4d3d-b0af-c38e0c1922ea"
      },
      "outputs": [],
      "source": [
        "dyn.register(setting_df)\n",
        "# Show summary\n",
        "dyn.summary()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "2PgvDnd_ajsg"
      },
      "source": [
        "High-lightened:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 143
        },
        "id": "uJwTUDxoagcH",
        "outputId": "55c5d265-4bf6-4bfd-ac7a-be37f779dc62"
      },
      "outputs": [],
      "source": [
        "dyn.summary().style.highlight_max(subset=[\"Rt\", \"rho\", \"1/beta [day]\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "OVKsl7aQ_Log"
      },
      "source": [
        "With the same way, we can set additional phases, if necessary for your analysis."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "ENWQFhxaXICA"
      },
      "source": [
        "### 1-3. Track ODE parameter values\n",
        "Confirm the phase-dependent ODE parameter values and Rt (reproduction number) by plotting."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 486
        },
        "id": "rUcWXTHwXXQc",
        "outputId": "185a4f04-3118-4f1e-db19-fb64b71316d2"
      },
      "outputs": [],
      "source": [
        "df = dyn.track()\n",
        "cs.line_plot(\n",
        "    df[\"Rt\"],\n",
        "    title=f\"Sample data of {dyn.model_name}: phase-dependent Rt values\",\n",
        "    ylabel=\"Reproduction number\",\n",
        "    show_legend=False,\n",
        "    v=dyn.start_dates()[1:]\n",
        ")\n",
        "df.loc[\"27Feb2022\": \"02Mar2022\"].style.highlight_max(subset=[\"Rt\", \"rho\", \"1/beta [day]\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "yK5iZz_FXXyX"
      },
      "source": [
        "### 1-4. Simulation\n",
        "With `Dynamics().simulate()`, simulate the phase-dependent ODE model with numerical analysis of each phase. Because we did not specify the initial values on the start date of the 1st phase, simulated values on the 1st phase's start date will be used as the initial values of the 1st phase."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "dNnw37Z_bZiu",
        "outputId": "9e0767eb-9f58-41e8-bab3-9bc917c5f46a"
      },
      "outputs": [],
      "source": [
        "df = dyn.simulate(model_specific=True)\n",
        "cs.line_plot(df, title=f\"Two-phase {dyn.model_name}\", v=dyn.start_dates()[1:])"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "vjJuz6u9XX2W"
      },
      "source": [
        "When we need convert model-specific variables to model-free variables (Susceptible/Infected/Fatal/Recovered), we will set `model_specific=False` (default).\n",
        "SIR model cannot separate \"Fatal\" cases and \"Recovered\" cases into different groups. Please use SIR-D model or SIR-F model if the following role is not acceptable for your analysis.\n",
        "\n",
        "- \"Fatal\" is always equal to 0\n",
        "- \"Recovered\" is equal to \"Fatal or Recovered\" of SIR model"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "L4qXK-sgb52h",
        "outputId": "ab1ee490-4107-404b-8470-4bacb4f006a7"
      },
      "outputs": [],
      "source": [
        "df = dyn.simulate(model_specific=False)\n",
        "cs.line_plot(df, title=f\"Two-phase {dyn.model_name}\", v=dyn.start_dates()[1:])"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "KMLu1rZhXX5f"
      },
      "source": [
        "### 1-5. Observable variables\n",
        "Actually, observable variables are Population/Confirmed/Infected/Recovered. We can calculate Population and Confirmed as follows.\n",
        "\n",
        "- Confirmed = Infected + Fatal + Recovered\n",
        "- Population = Susceptible + Confirmed"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "_cCXm157cWAQ",
        "outputId": "966c1ea5-1154-4c91-9cc0-5d3f0efccf67"
      },
      "outputs": [],
      "source": [
        "real_df = dyn.simulate(model_specific=False)\n",
        "real_df[\"Confirmed\"] = real_df[[\"Infected\", \"Fatal\", \"Recovered\"]].sum(axis=1)\n",
        "real_df[\"Population\"] = real_df[[\"Susceptible\", \"Confirmed\"]].sum(axis=1)\n",
        "real_df = real_df.loc[:, [\"Population\", \"Confirmed\", \"Recovered\", \"Fatal\"]]\n",
        "cs.line_plot(real_df, title=f\"Two-phase {dyn.model_name} with observable variables\", v=dyn.start_dates()[1:])"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "R7eOE1_9S8lR"
      },
      "source": [
        "## 2. S-R change point analysis\n",
        "S-R change point analysis (S-R trend analysis) is a technique to find the change points of phases with actual time-series data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "te79Q10hXXWe"
      },
      "source": [
        "### 2-1. S-R plane\n",
        "Author of the Kaggle Notebook considered S-R plane. This idea (S-R plane) is from [Balkew, Teshome Mogessie, \"The SIR Model When S(t) is a Multi-Exponential Function.\" (2010).Electronic Theses and Dissertations.Paper 1747](https://dc.etsu.edu/cgi/viewcontent.cgi?article=3102&context=etd). This is for simplest SIR model, but we can apply it to SIR-F model."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "NcJJsW0pcnys"
      },
      "source": [
        "We will focus on the following equations of SIR-derived ODE models.\n",
        "\n",
        "\\begin{align*}\n",
        "& \\frac{\\mathrm{d}S}{\\mathrm{d}T}= - \\frac{\\beta}{N} S I  \\\\\n",
        "& \\frac{\\mathrm{d}R}{\\mathrm{d}T}= \\gamma I  \\\\\n",
        "\\end{align*}"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "CA8yKFwFYIr4"
      },
      "source": [
        "When $I > 0$, this leads to\n",
        "\\begin{align*}\n",
        "& \\frac{\\mathrm{d}S}{\\mathrm{d}R}= - \\frac{\\beta}{N \\gamma} S  \\\\\n",
        "& \\beta, \\gamma, N: const.\n",
        "\\end{align*}"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "KfIEpOSIZ29u"
      },
      "source": [
        "Because $S(0) = N$, $S$ is a function of $R$ as follows."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 42
        },
        "id": "GTagHuQlSxL0",
        "outputId": "00b9dd12-4f8c-478b-c9cd-4b52370bc795"
      },
      "outputs": [],
      "source": [
        "S = sympy.symbols(\"S\", cls=sympy.Function)\n",
        "N, R  = sympy.symbols(\"N R\", positive=True)\n",
        "beta, gamma = sympy.symbols(r\"\\beta \\gamma\", positive=True)\n",
        "dS = - beta / (N * gamma) * S(R)\n",
        "sr = sympy.dsolve(S(R).diff(R) - dS, hint=\"separable\", ics={S(0): N})\n",
        "sr"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "TX8cRHYqb5zM"
      },
      "source": [
        "### 2-2. log(S) vs. R plane\n",
        "Then,"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 55
        },
        "id": "wzx6yxMob8wV",
        "outputId": "30d78ed8-05e7-4f7f-df34-e14b867f0546"
      },
      "outputs": [],
      "source": [
        "sympy.Eq(sympy.simplify(sympy.log(sr.lhs)), sympy.simplify(sympy.log(sr.rhs)))"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "xthi2mLbc0d5"
      },
      "source": [
        "Where $a=\\cfrac{\\beta}{N \\gamma} \\ (> 0)$,\n",
        "\\begin{align*}\n",
        "& \\log S_{(R)} = - a R + \\log N  \\\\\n",
        "& N: const.\n",
        "\\end{align*}"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "AUWFzfyTeL56"
      },
      "source": [
        " $\\log S$ decreases constantly with increase of $R$, when the records follow a SIR-derived model and the parameter values of the model are constant. Plot of $(x, y) = (R, \\log S)$ shows a line."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "QLSZBOARfqii",
        "outputId": "98088530-6a26-4296-938a-1e084ebdea9d"
      },
      "outputs": [],
      "source": [
        "model = deepcopy(cs.SIRFModel)\n",
        "sirf = model.from_sample()\n",
        "solved_df = sirf.solve()\n",
        "sr_df = model.sr(model.inverse_transform(solved_df))\n",
        "corr = sr_df[\"log10(S)\"].corr(sr_df[\"R\"]).round(5)\n",
        "cs.line_plot(\n",
        "    sr_df.set_index(\"R\"),\n",
        "    title=f\"{model.name()}: logS - R plane (corr: {corr})\",\n",
        "    xlabel=\"R\", xlim=(0, None),\n",
        "    ylabel=\"log10(S)\", ylim=(None, None),\n",
        "    show_legend=False\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "oHwpOuBtg2Mh"
      },
      "source": [
        "Initial values on the first date was set, but the summary shows just a phase with no set ODE parameter values."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Wz4bNHNkW_UG"
      },
      "source": [
        "Limitations:  \n",
        "Because $a=\\cfrac{\\beta}{N \\gamma}$, the changes of $\\alpha_1$ and $\\alpha_2$ of SIR-D/SIR-F model cannot be detected."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "lijK-hsatI1L"
      },
      "source": [
        "### 2-3. Plane of phase-dependent models\n",
        "Correlation coefficient is about -1.0 when ODE parameter values are constant The slope of the line may change when the ODE parameter values are changed."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "EdRpKxWqt8RH"
      },
      "source": [
        "Sample data of phase-dependent SIR-F model is here."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 269
        },
        "id": "H-eUolWdiGfT",
        "outputId": "b9ccdd06-34f8-416c-98be-d9c67b10bca5"
      },
      "outputs": [],
      "source": [
        "dyn = cs.Dynamics.from_sample(cs.SIRFModel, date_range=(\"01Jan2022\", \"30Jun2022\"))\n",
        "# Set some phases by changing ODE parameter values\n",
        "df = dyn.register()\n",
        "parameters = [\"theta\", \"kappa\", \"rho\", \"sigma\"]\n",
        "df.loc[\"18Feb2022\", parameters] = [0.0002, 0.005, 0.40, 0.075]\n",
        "df.loc[\"24Feb2022\", parameters] = [0.0002, 0.005, 0.15, 0.075]\n",
        "df.loc[\"01Mar2022\", parameters] = [0.0002, 0.003, 0.40, 0.075]\n",
        "df.loc[\"08Mar2022\", parameters] = [0.0002, 0.005, 0.40, 0.150]\n",
        "df.loc[\"15Mar2022\", parameters] = [0.0000, 0.005, 0.40, 0.150]\n",
        "dyn.register(df)\n",
        "# Show summary\n",
        "dyn.summary()[[\"Start\", \"End\", \"Rt\", *parameters]].style.format(precision=4).background_gradient()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "keBshVo3uCcN"
      },
      "source": [
        "Dynamics:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 300
        },
        "id": "AKlcoL52o9v_",
        "outputId": "ae360d01-1f84-466b-d708-a3a1f7a884e7"
      },
      "outputs": [],
      "source": [
        "model = deepcopy(cs.SIRFModel)\n",
        "df = dyn.simulate(model_specific=True)\n",
        "cs.line_plot(\n",
        "    df[[\"Susceptible\", \"Recovered\"]],\n",
        "    color_dict={\"Susceptible\": \"blue\", \"Recovered\": \"green\"},\n",
        "    title=f\"Phase-dependent {model.name()}: dynamics\",\n",
        "    v=dyn.start_dates()[1:],\n",
        "    bbox_to_anchor=(0.5, -0.3), bbox_loc=\"lower center\",\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "lppuH43MuEBO"
      },
      "source": [
        "Plot of $(R, \\log _{10} S)$: with vertical lines on change points (= start dates of phases 1st - last):"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "XjCu7EuxnjcH",
        "outputId": "714ade10-c488-467b-b661-858f2ac21d92"
      },
      "outputs": [],
      "source": [
        "model = deepcopy(cs.SIRFModel)\n",
        "# Get (R, log10S)\n",
        "sr_df = model.sr(dyn.simulate())\n",
        "# Plotting\n",
        "cs.line_plot(\n",
        "    sr_df.set_index(\"R\"),\n",
        "    title=f\"Phase-dependent {model.name()}: logS - R plane\\nwith vertical lines on change points\",\n",
        "    xlabel=\"R\", xlim=(0, None),\n",
        "    ylabel=\"log10(S)\", ylim=(None, None),\n",
        "    show_legend=False,\n",
        "    v=[sr_df.loc[d, \"R\"] for d in dyn.start_dates()[1:]],\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Cu1YDvX7uk90"
      },
      "source": [
        "With the plotting, we can confirm most of the change points (except for 5th - 6th: difficult because the change was for $\\alpha_1$)."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "cWtSYWl1csqV"
      },
      "source": [
        "### 2.4 Time-series segmentation\n",
        "The previous sub-sections demonstrated that change points of S-R trend suggest change points of phases. Here, we will detect the change points of S-R trend with `Dynamics().detect()` via `Dynamics.segment()`. They uses [ruptures library: change point detection in Python](https://github.com/deepcharles/ruptures) for off-line change point detection."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "MbgCfl4ieKF5"
      },
      "source": [
        "We will prepare a dataset which has the 0th - 5th phase."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 300
        },
        "id": "slT2powMegud",
        "outputId": "e04477e7-8b37-48cc-9176-cb1556b6b200"
      },
      "outputs": [],
      "source": [
        "dyn = cs.Dynamics.from_sample(cs.SIRFModel, date_range=(\"01Jan2022\", \"30Jun2022\"), tau=1440)\n",
        "# Set some phases by changing ODE parameter values\n",
        "df = dyn.register()\n",
        "parameters = [\"theta\", \"kappa\", \"rho\", \"sigma\"]\n",
        "df.loc[\"18Feb2022\", parameters] = [0.0002, 0.005, 0.40, 0.075]\n",
        "df.loc[\"24Feb2022\", parameters] = [0.0002, 0.005, 0.15, 0.075]\n",
        "df.loc[\"01Mar2022\", parameters] = [0.0002, 0.003, 0.40, 0.075]\n",
        "df.loc[\"08Mar2022\", parameters] = [0.0002, 0.005, 0.40, 0.150]\n",
        "df.loc[\"15Mar2022\", parameters] = [0.0000, 0.005, 0.40, 0.150]\n",
        "dyn.register(df)\n",
        "# Simulation\n",
        "sim_df = dyn.simulate(model_specific=False)\n",
        "cs.line_plot(\n",
        "    sim_df,\n",
        "    title=f\"Prepared dataset with phases and {dyn.model_name}\",\n",
        "    bbox_to_anchor=(0.5, -0.3),\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "jcU9JCfTfMY2"
      },
      "source": [
        "Create an instance of `Dynamics` with the prepared data. Note that the instance does not know the change points of phases."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 112
        },
        "id": "TN3lyZTqbENx",
        "outputId": "b14ca2be-43ed-4221-e725-b95366010c61"
      },
      "outputs": [],
      "source": [
        "dyn_sim = cs.Dynamics.from_data(model=cs.SIRFModel, data=sim_df, tau=None, name=\"Sample data\")\n",
        "# Show summary\n",
        "display(dyn_sim.summary())"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "mrzBo8Uhiwnw"
      },
      "source": [
        "`Dynamics().detect()` performs S-R change point analysis (trend analysis) and show the trend on S-R plane. Dot lines are the change points of phases.\n",
        "\n",
        "With `algo` argument, we can select the algorithm and models to detect the change points from “Binseg-normal” (default), “Pelt-rbf”, “Binseg-rbf”, “BottomUp-rbf”, “BottomUp-normal”. Please refer to [the documentation of ruptures library](https://centre-borelli.github.io/ruptures-docs/).\n",
        "\n",
        "Additionally, we can specify the minimum size of phases with argument `min_size=7` (as default, [days])."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 767
        },
        "id": "FmpX6W5ybt8g",
        "outputId": "914fc99f-3e63-4eeb-bd18-b54bf5642239"
      },
      "outputs": [],
      "source": [
        "points, fit_df = dyn_sim.detect(algo=\"Binseg-rbf\", min_size=7)\n",
        "# List of change points\n",
        "pprint(points)\n",
        "# Plotted values\n",
        "display(fit_df)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "wlACik1Tk2Xp"
      },
      "source": [
        "Note that detected phases are un-registered to the instance."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 112
        },
        "id": "bihPBw7Zk9jE",
        "outputId": "fcbde64a-d22c-47dc-ba19-9f46cb4eb477"
      },
      "outputs": [],
      "source": [
        "dyn_sim.summary()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "iYKQMuN7mgn0"
      },
      "source": [
        "To perform time-series segmentation with S-R trend analysis, we will use `Dynamics().segment()`, which accepts all keyword arguments of `Dynamics().detect()`."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 480
        },
        "id": "0MGrcG-gnDj7",
        "outputId": "52404408-20e7-4415-e312-e9ad96ee704c"
      },
      "outputs": [],
      "source": [
        "dyn_sim.segment(algo=\"Binseg-rbf\", min_size=7)\n",
        "# Show summary\n",
        "dyn_sim.summary()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "QsPLEU8unfag"
      },
      "source": [
        "If we need to add new change points or over-write change points, we will use `Dynamics().segment(points=<list>, overwrite=<bool>)`."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 206
        },
        "id": "jQHuS4BMn68R",
        "outputId": "2210a523-773d-4c6a-98c0-b16585a20c31"
      },
      "outputs": [],
      "source": [
        "# Over-write\n",
        "dyn_sim.segment(points=[\"01Mar2022\", \"01Jun2022\"], overwrite=True)\n",
        "# Add\n",
        "dyn_sim.segment(points=[\"01May2022\"], overwrite=False)\n",
        "# Show summary\n",
        "dyn_sim.summary()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Do_D_H5zTAPB"
      },
      "source": [
        "## 3. ODE parameter estimation\n",
        "This section demonstrates how to estimate tau value (constant for all phases) and the ODE parameter values of phases."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "exz8f6e9_80V"
      },
      "source": [
        "### 3.1 Preparation\n",
        "Create an `Dynamics()` instance which has a dataset with 6 phases (the 0th - 5th). The instance knows change points, but does not know tau value and ODE parameter values."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "NtoiVicmAwZt"
      },
      "source": [
        "Create dataset."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 300
        },
        "id": "UcNvQ20UAlje",
        "outputId": "3d8526fb-ad66-46d0-cbf9-285263140808"
      },
      "outputs": [],
      "source": [
        "dyn = cs.Dynamics.from_sample(cs.SIRFModel, date_range=(\"01Jan2022\", \"30Jun2022\"), tau=1440)\n",
        "# Set some phases by changing ODE parameter values\n",
        "df = dyn.register()\n",
        "parameters = [\"theta\", \"kappa\", \"rho\", \"sigma\"]\n",
        "df.loc[\"18Feb2022\", parameters] = [0.0002, 0.005, 0.40, 0.075]\n",
        "df.loc[\"24Feb2022\", parameters] = [0.0002, 0.005, 0.15, 0.075]\n",
        "df.loc[\"01Mar2022\", parameters] = [0.0002, 0.003, 0.40, 0.075]\n",
        "df.loc[\"08Mar2022\", parameters] = [0.0002, 0.005, 0.40, 0.150]\n",
        "df.loc[\"15Mar2022\", parameters] = [0.0000, 0.005, 0.40, 0.150]\n",
        "dyn.register(df)\n",
        "# Simulation\n",
        "sim_df = dyn.simulate(model_specific=False)\n",
        "cs.line_plot(\n",
        "    sim_df,\n",
        "    title=f\"Prepared dataset with phases and {dyn.model_name}\",\n",
        "    bbox_to_anchor=(0.5, -0.3),\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "N_UvBaZYA9l0"
      },
      "source": [
        "Create `Dynamics()` instance."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 286
        },
        "id": "H9snUqKAA5Zf",
        "outputId": "6fa6a424-864d-419e-eb3d-7246798c0f9f"
      },
      "outputs": [],
      "source": [
        "dyn_est = cs.Dynamics.from_data(cs.SIRFModel, data=sim_df, tau=None, name=\"Sample data\")\n",
        "dyn_est.segment(points=[\"18Feb2022\", \"24Feb2022\", \"01Mar2022\", \"08Mar2022\", \"15Mar2022\"])\n",
        "# Show tau value\n",
        "print(f\"Tau value [min]: {dyn_est.tau or 'un-set'}\")\n",
        "# Show summary\n",
        "display(dyn_est.summary())"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "gIgw2aWiZZOd"
      },
      "source": [
        "### 3.2 Tau estimation\n",
        "Before ODE parameter estimation, we need to select tau value [min]. Tau value is expected to be constant for all phases because tau value is a parameter used to convert actual time (with unit [min]) to time steps (without units) from divisors of 1440).\n",
        "\n",
        "`Dynamics().estimate_tau(metric=\"RMSLE\", q=0.5, digits=None, n_jobs=None)` (as default) sets the best tau value for the registered data, estimating ODE parameters with quantiles.\n",
        "\n",
        "Arguments:\n",
        "\n",
        "* metric (str): metric name for scoring when selecting best tau value\n",
        "* q (float): the quantiles to compute, values between (0, 1)\n",
        "* digits (int or None): effective digits of ODE parameter values or None (skip rounding)\n",
        "* n_jobs (int or None): the number of parallel jobs or None (CPU count)\n",
        "\n",
        "Metrics (selectable candidates of `metric`):\n",
        "\n",
        "* ME: maximum residual error\n",
        "* MAE: mean absolute error\n",
        "* MSE: mean square error\n",
        "* MSLE: mean squared logarithmic error\n",
        "* MAPE: mean absolute percentage error\n",
        "* RMSE: root mean squared error\n",
        "* RMSLE: root mean squared logarithmic error\n",
        "* R2: the coefficient of determination\n",
        "\n",
        "\n",
        "For example, RMSLE score will be calculated with the following equation.\n",
        "\\begin{align*}\n",
        "\\mathrm{RMSLE} = \\sqrt{\\cfrac{1}{n}\\sum_{i=1}^{n}(log_{10}(A_{i} + 1) - log_{10}(P_{i} + 1))^2}\n",
        "\\end{align*}\n",
        "Where $A$ is the observed (actual) values, $P$ is estimated (predicted) values. Variables are $S (i=1), I (i=2), R (i=3)\\ \\mathrm{and}\\ F (i=n=4)$ for SIR-F model. When RMSLE score is low, hyperparameter estimation is highly accurate. Please refer to external sites, including [Medium: What’s the Difference Between RMSE and RMSLE?](https://medium.com/analytics-vidhya/root-mean-square-log-error-rmse-vs-rmlse-935c6cc1802a)."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 309
        },
        "id": "5pk2pASUFfUS",
        "outputId": "93434b62-15cd-4673-f1b7-831d55819970"
      },
      "outputs": [],
      "source": [
        "metric = \"RMSLE\"\n",
        "tau, score_df = dyn_est.estimate_tau(metric=metric)\n",
        "print(f\"Tau value [min]: {dyn_est.tau or 'un-set'}\")\n",
        "score_df.plot.line(\n",
        "    title=f\"Tau estimation: {metric} scores (selected tau: {tau} [min])\",\n",
        "    xlabel=\"Tau value [min]\", ylabel=metric, legend=False\n",
        ");"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "ntZeNrycLCMZ"
      },
      "source": [
        "### 3.3 ODE parameter estimation\n",
        "`Dynamics().estimate_params(metric=\"RMSLE\", digits=None, n_jobs=None, **kwargs)` (as default) sets ODE parameter values optimized for the registered data with hyperparameter optimization using [Optuna library](https://github.com/optuna/optuna).\n",
        "\n",
        "Arguments of `Dynamics().estimate_params`:\n",
        "\n",
        "* metric (str): metric name for scoring when optimizing ODE parameter values of phases\n",
        "* digits (int or None): effective digits of ODE parameter values or None (skip rounding)\n",
        "* n_jobs (int or None): the number of parallel jobs or None (CPU count)\n",
        "* **kwargs: keyword arguments of optimization\n",
        "    * quantiles (tuple(int, int)): quantiles to cut parameter range, like confidence interval, (0.1, 0.9) as default\n",
        "    * timeout (int): timeout of optimization, 180 as default\n",
        "    * timeout_iteration (int): timeout of one iteration, 1 as default\n",
        "    * tail_n (int): the number of iterations to decide whether score did not change for the last iterations, 4 as default\n",
        "    * allowance (tuple(float, float)): the allowance of the max predicted values, (0.99, 1.01) as default\n",
        "    * pruner (str): kind of pruner (hyperband, median, threshold or percentile), \"threshold\" as default\n",
        "    * upper (float): works for \"threshold\" pruner, intermediate score is larger than this value, it prunes, 0.5 as default\n",
        "    * percentile (float): works for \"Percentile\" pruner, the best intermediate value is in the bottom percentile among trials, it prunes, 50 as default\n",
        "    * constant_liar (bool): whether use constant liar to reduce search effort or not, False as default"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 460
        },
        "id": "8hGCWgsmNrzQ",
        "outputId": "71371225-326c-4e5a-8e88-e99219ad06e3"
      },
      "outputs": [],
      "source": [
        "est_df = dyn_est.estimate_params()\n",
        "# Show RMSLE scores pf phases\n",
        "est_df = est_df.drop_duplicates()\n",
        "est_df.index.name = \"Start\"\n",
        "display(est_df)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 313
        },
        "id": "fpnL63K0QJWt",
        "outputId": "db41fe33-004c-4b33-c285-d048d0a1dfa6"
      },
      "outputs": [],
      "source": [
        "dyn_est.summary()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "j6TdX8d0ypui"
      },
      "source": [
        "## 4. With actual data\n",
        "This section demonstrates how to divide actual time-series data with phases (\"S-R change point analysis\") and to estimate ODE parameter values of phases (\"ODE parameter estimation\")."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Gtxn1Rb4ykO3"
      },
      "source": [
        "### 4-1. Data preparation\n",
        "Prepare actual prefecture-level time-series data in Japan for demonstration."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "uX5PyJ3oycno"
      },
      "source": [
        "Download the dataset."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "fyDXuJGRyd1Y",
        "outputId": "2b740ef5-0400-42af-995f-5d53333270dc"
      },
      "outputs": [],
      "source": [
        "eng = cs.DataEngineer()\n",
        "eng.download(country=None, databases=[\"japan\", \"covid19dh\"]);"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "7_2NSubiyZxn"
      },
      "source": [
        "Data cleaning, transformation, subsetting, complement."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 290
        },
        "id": "3HgEyZ2MyToz",
        "outputId": "b0e2d50e-f5bd-4032-870f-53424ea81d07"
      },
      "outputs": [],
      "source": [
        "eng.clean()\n",
        "eng.transform()\n",
        "actual_df, status, _ = eng.subset(geo=(\"Japan\",), variables=\"SIRF\", complement=True)\n",
        "print(status)\n",
        "actual_df.tail()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "AQJ0cehsyOzS"
      },
      "source": [
        "Plotting: removed \"Susceptible\" from the figure because \"Susceptible\" >> max(\"Infected\", \"Infected\", \"Recovered\")."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "V4wov0m-gFzt",
        "outputId": "6dbc2b8e-02ca-45b5-fc75-17014e9ac5e2"
      },
      "outputs": [],
      "source": [
        "cs.line_plot(actual_df.drop(\"Susceptible\", axis=1), \"Actual data in Japan\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "CIVFeSLXgXZg"
      },
      "source": [
        "With the data, create an instance of `Dynamics` class."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 238
        },
        "id": "M2ONiP5Age0D",
        "outputId": "5d5d0c83-51c6-4b04-e942-bee22a6b5aee"
      },
      "outputs": [],
      "source": [
        "dyn_act = cs.Dynamics.from_data(model=cs.SIRFModel, data=actual_df, name=\"Japan\")\n",
        "# Show registered values\n",
        "dyn_act.register().tail()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 112
        },
        "id": "xcEItU_RhaQI",
        "outputId": "d64250f1-0bfb-4cb0-b306-992e7b8b44cf"
      },
      "outputs": [],
      "source": [
        "# Show summary\n",
        "dyn_act.summary()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "9mSf2WevzX8o"
      },
      "source": [
        "### 4-2. Time-series segmentation\n",
        "With `Dynamics.segment()`, we will apply S-R change point analysis (trend analysis) to the prepared actual data."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 418
        },
        "id": "xqIT8cgIz428",
        "outputId": "06ce58bc-162c-4868-ca87-56b53da3f842"
      },
      "outputs": [],
      "source": [
        "dyn_act.segment();\n",
        "# Show summary\n",
        "dyn_act.summary().T"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Y0T69l_GZaaR"
      },
      "source": [
        "### 4-3. Parameter estimation\n",
        "`Dynamics().estimate(**kwargs)` performs `Dynamics().estimate_tau()` and `Dynamics().estimate_params()` in order."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 814
        },
        "id": "FH1VR1Y3TBo5",
        "outputId": "65068c84-1421-4c19-a1a4-4bdfb13a9b8a"
      },
      "outputs": [],
      "source": [
        "dyn_act.estimate()\n",
        "print(f\"Tau value [min]: {dyn_act.tau or 'un-set'}\")\n",
        "# Show summary\n",
        "dyn_act.summary()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "dUWqKegYavEz"
      },
      "source": [
        "### 4-4. Accuracy evaluation\n",
        "Compare the simulated results and actual records, and evaluate the differences.\n",
        "\n",
        "Arguments:\n",
        "- date_range (tuple of (str or pandas.Timestamp or None) or None): range of dates to evaluate or None (the first and the last date)\n",
        "- metric (str): metric to evaluate the difference, \"RMSLE\" as default\n",
        "- display (bool): whether display figure of comparison or not\n",
        "- kwargs: keyword arguments of `covsirphy.compare_plot()`"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 890
        },
        "id": "OUgWyXafbKt8",
        "outputId": "1796b8b0-f27d-4ce4-dcfa-0b109868d7fc"
      },
      "outputs": [],
      "source": [
        "metric = \"RMSLE\"\n",
        "score = dyn_act.evaluate(metric=metric)\n",
        "print(f\"{metric}: {score:.4} (overall score for time-series segmentation, tau estimation and ODE parameter estimation)\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "DnjXyhedb-5q"
      },
      "source": [
        "### 4-5. Simulation\n",
        "Simulate the dynamics with the estimated parameter sets of phases."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "H2OeoFMGdc7C"
      },
      "outputs": [],
      "source": [
        "simulated_df = dyn_act.simulate()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 300
        },
        "id": "aqcukbQPcJZq",
        "outputId": "7572918d-7fa4-4ccb-c099-27871c632f6a"
      },
      "outputs": [],
      "source": [
        "cs.line_plot(\n",
        "    simulated_df.drop(\"Susceptible\", axis=1),\n",
        "    title=\"Simulated data in Tokyo/Japan\",\n",
        "    v=dyn_act.start_dates()[1:],\n",
        "    bbox_to_anchor=(0.5, -0.3),\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Q4-GsiBVc8el"
      },
      "source": [
        "When we need to simulate for the last 30 days, we can use `Dynamics().parse_days(days=-30, ref=\"last\")`."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 294
        },
        "id": "7zhsVFdPdZ1w",
        "outputId": "86cf0c85-fcdc-4f79-8e30-0338cb6a88c9"
      },
      "outputs": [],
      "source": [
        "start, end = dyn_act.parse_days(days=-30, ref=\"last\")\n",
        "cs.line_plot(\n",
        "    simulated_df.drop(\"Susceptible\", axis=1).loc[start: end],\n",
        "    title=f\"Simulated: Japan, {start: %Y-%m-%d} - {end: %Y-%m-%d}\",\n",
        "    bbox_to_anchor=(0.5, -0.3),\n",
        "    y_integer=True,\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "SxEbdWVngFGK"
      },
      "source": [
        "When we need to perform simulation for th 5th and 6th phase, We can use `Dynamics().parse_phases(phases=[\"5th\", \"6th\"])`)."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 294
        },
        "id": "aB8xJ3Q2f17B",
        "outputId": "c01250c7-632c-4473-c80e-8d9f4d184703"
      },
      "outputs": [],
      "source": [
        "start, end = dyn_act.parse_phases(phases=[\"5th\", \"6th\"])\n",
        "cs.line_plot(\n",
        "    simulated_df.drop(\"Susceptible\", axis=1).loc[start: end],\n",
        "    title=f\"Simulated: Japan, {start: %Y-%m-%d} - {end: %Y-%m-%d}\",\n",
        "    bbox_to_anchor=(0.5, -0.3),\n",
        "    y_integer=True,\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "4wCZTY8mgjKI"
      },
      "source": [
        "### 4-6. Tracking of ODE parameters\n",
        "Track the estimated ODE parameter values."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 238
        },
        "id": "BSlhTVejgzZ6",
        "outputId": "1961ad71-8664-4493-e280-7971fe269fc0"
      },
      "outputs": [],
      "source": [
        "track_df = dyn_act.track()\n",
        "track_df.tail()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "CJ7fyqVYjeAl",
        "outputId": "d46ce775-4547-4611-856f-f332f44d5d46"
      },
      "outputs": [],
      "source": [
        "track_df.columns"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "tdS-WgkWh1e6"
      },
      "outputs": [],
      "source": [
        "def history(param_name, title=None, h=None):\n",
        "    \"\"\"Display the history of ODE parameter values tracked with global `track_df`.\n",
        "    \n",
        "    Args:\n",
        "        param_name (str): name of the parameter\n",
        "        title (str or None): figure title or Nome (@param_name will be used)\n",
        "        h (list/tuple[int/float] or None): list of y values of horizontal lines or None\n",
        "    \"\"\"\n",
        "    global track_df\n",
        "    cs.line_plot(\n",
        "        track_df.loc[:, param_name],\n",
        "        title=title or f\"Tracked {param_name}\",\n",
        "        ylabel=param_name,\n",
        "        math_scale=False,\n",
        "        h=h,\n",
        "        show_legend=False,\n",
        "    )"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Xe8N4Ty2gte5"
      },
      "source": [
        "$\\theta$ and $\\alpha_1$:  \n",
        "Enhancement of PCR tests suppressed the number of fatal cases before confirmation."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "nAYDzakQgxGy",
        "outputId": "9ee1177b-df6a-4053-fcd5-e02af81ae67e"
      },
      "outputs": [],
      "source": [
        "history(\"theta\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "Bj-5qBSci4iS",
        "outputId": "874be414-33c5-46a2-8df5-b98bb65f307d"
      },
      "outputs": [],
      "source": [
        "history(\"alpha1 [-]\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "6SvQAubXhZbZ"
      },
      "source": [
        "$\\kappa$ and $1/\\alpha_2$:  \n",
        "Enhancement of medical system suppressed the number of fatal cases."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "cr1Bf-_pgxJ4",
        "outputId": "f569100d-80c0-465c-afb2-895e2f865c0f"
      },
      "outputs": [],
      "source": [
        "history(\"kappa\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "YbpBjmXNjtYO",
        "outputId": "4a3084cb-f7ff-4778-8be3-cb1165e89793"
      },
      "outputs": [],
      "source": [
        "history(\"1/alpha2 [day]\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "jylsSvErhc36"
      },
      "source": [
        "$\\rho$ and $1/\\beta$:  \n",
        "Contact rate was changed with emergency declaration in Tokyo."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "rFu5Z_MWgxMI",
        "outputId": "6a3dd1c9-393c-4097-d5d7-530a4dd69fe2"
      },
      "outputs": [],
      "source": [
        "history(\"rho\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "SZLa-h-jjwhO",
        "outputId": "a0c92b18-8ae9-4173-ed13-7bb05518cbf8"
      },
      "outputs": [],
      "source": [
        "history(\"1/beta [day]\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "c8V_jaPOhtFS"
      },
      "source": [
        "$\\sigma$ and $1/\\gamma$:  \n",
        "Recovery period is not changed clearly at this time."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "q2PQs1SGgxOp",
        "outputId": "92f3c5ee-b198-4015-f497-81f357367c39"
      },
      "outputs": [],
      "source": [
        "history(\"sigma\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "WFVjEAFbjxV1",
        "outputId": "9354beda-f06a-4b03-c46b-c64d68577304"
      },
      "outputs": [],
      "source": [
        "history(\"1/gamma [day]\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "QvFF5piEhxCf"
      },
      "source": [
        "Reproduction number:  \n",
        "Rt > 1 means explosive outbreak."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "BOBswDZ6gxQ_",
        "outputId": "bcc5f45f-9f28-4c70-d30c-421b9fd75618"
      },
      "outputs": [],
      "source": [
        "history(\"Rt\", title=\"Tracked reproduction number\", h=1.0)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "0zCi_W-DcW-7"
      },
      "source": [
        "Thank you!"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "collapsed_sections": [],
      "include_colab_link": true,
      "name": "04_phase_dependent.ipynb",
      "provenance": [],
      "toc_visible": true
    },
    "kernelspec": {
      "display_name": "Python 3.9.8 ('.venv': poetry)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "name": "python",
      "version": "3.10.7"
    },
    "vscode": {
      "interpreter": {
        "hash": "22bb74880181aee4909a67ef083e714bf83db977b91038d43aef8b1870a4f681"
      }
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
